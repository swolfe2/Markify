Of course. Dealing with bi-directional relationships and varying column names is a common challenge. Forcing a specific execution order—deleting old relationships before creating new ones—is the most reliable way to prevent ambiguity errors that block bi-directional filters.

Here is the revised C\# script for Tabular Editor. It incorporates the requested changes to handle different column names and restructures the logic to delete existing relationships first, which should resolve the timing issues with bi-directional relationships.

### **Key Improvements:**

  * **Handles Different Column Names:** The script now uses `oldColumnName` and `newColumnName` variables, so the key columns in the old and new tables no longer need to match.
  * **Resolves Bi-directional Failures:** The logic has been changed to first collect all relationship metadata, then **delete** the old relationships, and finally create the new ones. This prevents model ambiguity errors that commonly cause bi-directional relationships to fail on creation.
  * **Streamlined Logging:** The comments and log output have been updated to reflect the new, more robust workflow.

<!-- end list -->

```csharp
/*
===========================================================================================
RELATIONSHIP MIGRATION SCRIPT
-------------------------------------------------------------------------------------------
Author: Steve Wolfe (Data Viz CoE), Revised by Gemini
Purpose:
This script is designed for use in Tabular Editor to migrate all relationships from a
specific column in an existing table (e.g., a DAX-generated "Date" table) to a new table
(e.g., a Power Query-based "Date Table"). It deletes the original relationships before
creating the new ones to prevent ambiguity errors, especially with bi-directional
relationships.

Key Features:
- Collects all relationships linked to the specified old table and column.
- Deletes the old relationships to prevent validation errors.
- Recreates each relationship using the new table’s column.
- Preserves:
    • Active/inactive status
    • Cross-filtering behavior (with explicit enum handling)
    • Security filtering
    • Referential integrity
    • Join-on-date behavior
    • Cardinality (from/to)
- Logs a summary of all operations and highlights any failures.

Use Case:
Ideal for replacing a shared dimension table (like a Date table) while maintaining
relationship integrity and avoiding ambiguous paths or DirectQuery/Import conflicts.

Output:
- A summary of actions and issues is printed to the Output window.

===========================================================================================
*/

var oldTableName = "Date";          // Original table to migrate relationships from
var oldColumnName = "Date";         // Key column in the OLD table
var newTableName = "Date Table";    // New table to migrate relationships to
var newColumnName = "Date";         // Key column in the NEW table

// Retrieve references to the old and new tables
var oldTable = Model.Tables[oldTableName];
var newTable = Model.Tables[newTableName];

// Validate that both tables exist
if (oldTable == null || newTable == null)
{
    Error("One or both tables were not found! Verify table names.");
    return;
}

// Retrieve the key columns from the old and new tables
var oldColumn = oldTable.Columns[oldColumnName];
var newColumn = newTable.Columns[newColumnName];
if (oldColumn == null || newColumn == null)
{
    Error("One or both key columns were not found! Verify column names.");
    return;
}

// Step 1: Collect all relationship metadata involving the old table's specific column
var relationshipInfo = new List<dynamic>();
var oldRelationshipsToDelete = new List<dynamic>();

foreach (var oldRel in Model.Relationships.Where(r => (r.FromTable == oldTable && r.FromColumn == oldColumn) || (r.ToTable == oldTable && r.ToColumn == oldColumn)).ToList())
{
    relationshipInfo.Add(new {
        FromColumn = oldRel.FromColumn,
        ToColumn = oldRel.ToColumn,
        IsActive = oldRel.IsActive,
        CrossFilteringBehavior = oldRel.CrossFilteringBehavior,
        SecurityFilteringBehavior = oldRel.SecurityFilteringBehavior,
        RelyOnReferentialIntegrity = oldRel.RelyOnReferentialIntegrity,
        JoinOnDateBehavior = oldRel.JoinOnDateBehavior,
        FromCardinality = oldRel.FromCardinality,
        ToCardinality = oldRel.ToCardinality,
        Name = oldRel.Name,
        OldTableWasFrom = (oldRel.FromTable == oldTable)
    });
    oldRelationshipsToDelete.Add(oldRel);
}

// Initialize a summary log
var summary = "RELATIONSHIP MIGRATION SCRIPT:\n";
summary += "Found " + relationshipInfo.Count + " relationships to migrate from '" + oldTableName + "'[" + oldColumnName + "].\n\n";

// ============================================================================
// Step 2: DELETE OLD RELATIONSHIPS TO PREVENT AMBIGUOUS PATHS
// This is a required step to ensure bi-directional relationships can be created.
// ============================================================================
summary += "=== DELETING OLD RELATIONSHIPS ===\n";
if (oldRelationshipsToDelete.Count == 0)
{
    summary += "No relationships found to delete.\n";
}
else
{
    foreach (var oldRel in oldRelationshipsToDelete)
    {
        try
        {
            var relName = oldRel.FromTable.Name + " -> " + oldRel.ToTable.Name;
            oldRel.Delete();
            summary += "Deleted: " + relName + "\n";
        }
        catch (Exception ex)
        {
            summary += "Failed to delete relationship: " + ex.Message + "\n";
        }
    }
}
summary += "\n";

// Step 3: Create new relationships using the new table
summary += "=== CREATING NEW RELATIONSHIPS ===\n";
var failedBidirectional = new List<string>();

foreach (var relInfo in relationshipInfo)
{
    try
    {
        var newRel = Model.AddRelationship();

        // Assign the correct From/To columns based on the original direction
        if (relInfo.OldTableWasFrom)
        {
            newRel.FromColumn = newColumn;
            newRel.ToColumn = relInfo.ToColumn;
        }
        else
        {
            newRel.FromColumn = relInfo.FromColumn;
            newRel.ToColumn = newColumn;
        }

        // Set cardinality and other relationship properties
        newRel.FromCardinality = relInfo.FromCardinality;
        newRel.ToCardinality = relInfo.ToCardinality;
        newRel.IsActive = relInfo.IsActive;
        newRel.SecurityFilteringBehavior = relInfo.SecurityFilteringBehavior;
        newRel.RelyOnReferentialIntegrity = relInfo.RelyOnReferentialIntegrity;
        newRel.JoinOnDateBehavior = relInfo.JoinOnDateBehavior;

        // Set cross-filtering behavior using explicit enum mapping
        var originalCrossFilter = relInfo.CrossFilteringBehavior.ToString();
        if (originalCrossFilter == "BothDirections")
        {
            newRel.CrossFilteringBehavior = CrossFilteringBehavior.BothDirections;
        }
        else if (originalCrossFilter == "OneDirection")
        {
            newRel.CrossFilteringBehavior = CrossFilteringBehavior.OneDirection;
        }
        else if (originalCrossFilter == "Automatic")
        {
            newRel.CrossFilteringBehavior = CrossFilteringBehavior.Automatic;
        }

        // Verify if the cross-filtering behavior was applied successfully
        var actualResult = newRel.CrossFilteringBehavior.ToString();
        var success = (actualResult == originalCrossFilter) ? "SUCCESS" : "FAILED";
        summary += newRel.FromTable.Name + " -> " + newRel.ToTable.Name + ": " + success + " (" + originalCrossFilter + " -> " + actualResult + ")\n";

        // Track failed bidirectional attempts for review
        if (success == "FAILED" && originalCrossFilter == "BothDirections")
        {
            failedBidirectional.Add(newRel.FromTable.Name + " -> " + newRel.ToTable.Name);
        }

        // Rename the relationship if it had a name
        if (!string.IsNullOrEmpty(relInfo.Name))
        {
            newRel.Name = relInfo.Name.Replace(oldTableName, newTableName);
        }
    }
    catch (Exception ex)
    {
        summary += "Failed to create relationship: " + ex.Message + "\n";
    }
}

// Step 4: Report any failed bidirectional relationships
if (failedBidirectional.Count > 0)
{
    summary += "\n=== MANUAL REVIEW REQUIRED ===\n";
    summary += "The following relationships could not be set to bidirectional:\n";
    foreach (var rel in failedBidirectional)
    {
        summary += "• " + rel + "\n";
    }

    summary += "\nPossible causes:\n";
    summary += "• DirectQuery/Import mode mixing (expected limitation)\n";
    summary += "• Other model validation constraints are preventing this path\n";
}

// Final notes
summary += "\n=== COMPLETION NOTES ===\n";
summary += "• Script completed.\n";
summary += "• Review the log above for any FAILED items.\n";
summary += "• DirectQuery/Import cross-filtering limitations are normal and cannot be scripted around.\n";

// Output the summary to the Output window
Info(summary);
```
